<script>
document.addEventListener('DOMContentLoaded', () => {
  const root = document.querySelector('[data-cart-root]');
  if (!root) return;

  const $  = (sel, ctx = root) => ctx.querySelector(sel);
  const $$ = (sel, ctx = root) => Array.from(ctx.querySelectorAll(sel));

  // ==========================================================
  // A11y live region (no spam + throttle)
  // ==========================================================
  const live = $('[data-cart-live]');
  let lastLive = "";
  let liveTimer = null;

  const say = (msg) => {
    if (!live) return;
    const s = String(msg || "").trim();
    if (!s || s === lastLive) return;
    lastLive = s;

    // throttle para evitar spam a screenreaders
    if (liveTimer) clearTimeout(liveTimer);
    liveTimer = setTimeout(() => { live.textContent = s; }, 120);
  };

  // ==========================================================
  // Summary nodes (null-safe)
  // ==========================================================
  const metaEl      = $('[data-cart-meta]');
  const subtotalEl  = $('[data-subtotal]');
  const discountEl  = $('[data-discount]');
  const discountRow = $('[data-discount-row]');
  const totalEl     = $('[data-total]');

  // ==========================================================
  // Utils
  // ==========================================================
  const clamp = (n, a, b) => Math.min(b, Math.max(a, n));
  const toInt = (v, def = 1) => {
    const n = parseInt(String(v ?? ''), 10);
    return Number.isFinite(n) ? n : def;
  };
  const safeStr = (v, def = "") => {
    if (v === null || v === undefined) return def;
    return String(v);
  };
  const nowMs = () => (Date.now ? Date.now() : new Date().getTime());

  // ==========================================================
  // Toast safe (no rompe nunca)
  // ==========================================================
  const toastSafe = (t, m) => {
    try { if (window.toast) window.toast(String(t || "Info"), String(m || "")); } catch(e){}
  };

  // ==========================================================
  // CSRF auto (si existe; si no, no rompe)
  // ==========================================================
  const readCsrf = () => {
    try{
      const meta = document.querySelector('meta[name="csrf-token"]');
      if (meta && meta.content) return meta.content;
      const inp = document.querySelector('input[name="csrf_token"]');
      if (inp && inp.value) return inp.value;
    }catch(e){}
    return "";
  };
  let csrf = readCsrf();

  // ==========================================================
  // Error message helper
  // ==========================================================
  const errMsg = (j) => {
    if (!j) return "Request failed";
    if (typeof j === "string") return j;
    if (j?.error?.message) return j.error.message;
    if (typeof j?.error === "string") return j.error;
    if (j?.message) return j.message;
    return "Request failed";
  };

  // ==========================================================
  // Abort controllers (cancel prev by key)
  // ==========================================================
  const controllers = new Map();
  const abortPrev = (key) => {
    const c = controllers.get(key);
    if (c) { try { c.abort(); } catch(e){} }
    const nc = new AbortController();
    controllers.set(key, nc);
    return nc;
  };

  // ==========================================================
  // API wrappers (fallback seguro)
  // - soporta window.apiGet/apiPost
  // - soporta /cart/json retornando {cart:...} o directo
  // ==========================================================
  const apiGet = async (url, key = "get") => {
    const ctrl = abortPrev(key);

    if (typeof window.apiGet === "function") {
      const d = await window.apiGet(url);
      return d;
    }

    const r = await fetch(url, {
      headers: { "Accept": "application/json" },
      credentials: "same-origin",
      signal: ctrl.signal
    });

    let j = {};
    try { j = await r.json(); } catch(e) { j = {}; }

    if (!r.ok || j?.ok === false) throw new Error(errMsg(j));
    return j;
  };

  const apiPost = async (url, body, key = "post") => {
    const ctrl = abortPrev(key);

    if (typeof window.apiPost === "function") {
      const d = await window.apiPost(url, body);
      return d;
    }

    const headers = {
      "Content-Type": "application/json",
      "Accept": "application/json"
    };

    csrf = csrf || readCsrf();
    if (csrf) headers["X-CSRF-Token"] = csrf;

    const doReq = async () => {
      const r = await fetch(url, {
        method: "POST",
        headers,
        credentials: "same-origin",
        body: JSON.stringify(body || {}),
        signal: ctrl.signal
      });
      let j = {};
      try { j = await r.json(); } catch(e) { j = {}; }
      return { r, j };
    };

    const { r, j } = await doReq();

    // retry 1 vez si parece CSRF
    const msg = errMsg(j);
    const looksCsrf = /csrf|token/i.test(msg);
    if ((!r.ok || j?.ok === false) && looksCsrf) {
      const fresh = readCsrf();
      if (fresh && fresh !== csrf) {
        csrf = fresh;
        headers["X-CSRF-Token"] = csrf;

        const { r: r2, j: j2 } = await doReq();
        if (!r2.ok || j2?.ok === false) throw new Error(errMsg(j2));
        return j2;
      }
    }

    if (!r.ok || j?.ok === false) throw new Error(msg);
    return j;
  };

  // ==========================================================
  // Snapshot normalizer (cart payload flexible)
  // ==========================================================
  const pickCart = (d) => {
    // soporta: {cart:{...}} o {...cart fields...}
    if (!d) return null;
    if (d.cart && typeof d.cart === "object") return d.cart;
    return d;
  };

  // ==========================================================
  // Apply snapshot to UI
  // ==========================================================
  const setSummary = (snap) => {
    if (!snap) return;

    const itemsCount = safeStr(snap.items_count ?? 0, "0");
    const distinct   = safeStr(snap.distinct_items ?? 0, "0");

    if (metaEl) metaEl.textContent = `${itemsCount} item(s) • ${distinct} producto(s)`;
    if (subtotalEl) subtotalEl.textContent = safeStr(snap.subtotal, "0.00");

    const disc = safeStr(snap.discount_total, "0.00");
    if (discountEl) discountEl.textContent = disc;
    if (discountRow) discountRow.style.display = (disc && disc !== "0.00") ? "" : "none";

    if (totalEl) totalEl.textContent = safeStr(snap.total || snap.subtotal, "0.00");
  };

  const renderLines = (snap) => {
    if (!snap || !Array.isArray(snap.lines)) return;

    // update existentes (solo toca lo necesario)
    for (const ln of snap.lines) {
      const pid = safeStr(ln.product_id, "");
      if (!pid) continue;

      const row = root.querySelector(`[data-line][data-id="${CSS.escape(pid)}"]`);
      if (!row) continue;

      const qtyInput  = row.querySelector('[data-qty-input]');
      const lineTotal = row.querySelector('[data-line-total]');
      const unit      = row.querySelector('[data-unit]');

      const qtyVal = safeStr(ln.qty ?? 1, "1");
      if (qtyInput && qtyInput.value !== qtyVal) qtyInput.value = qtyVal;

      const lt = safeStr(ln.line_total_display || ln.line_total, "0.00");
      if (lineTotal && lineTotal.textContent !== lt) lineTotal.textContent = lt;

      const up = safeStr(ln.unit_price_display || ln.unit_price, "0.00");
      if (unit && unit.textContent !== up) unit.textContent = up;
    }

    // remove líneas inexistentes
    const ids = new Set(snap.lines.map(x => safeStr(x.product_id, "")));
    for (const el of $$('[data-line]')) {
      const id = el.getAttribute('data-id');
      if (id && !ids.has(id)) {
        el.classList.add('fade-out');
        setTimeout(() => el.remove(), 220);
      }
    }
  };

  const emitUpdated = (snap) => {
    try{
      window.dispatchEvent(new CustomEvent('cart:updated', { detail: { cart: snap } }));
    }catch(e){}
  };

  const applySnap = (snap) => {
    if (!snap) return;

    setSummary(snap);
    renderLines(snap);

    // sync global store si existe
    if (window.CartStore && typeof window.CartStore.update === 'function') {
      try { window.CartStore.update(snap); } catch(e) {}
    }

    emitUpdated(snap);
  };

  // ==========================================================
  // Busy lock SOLO acciones carrito (checkout siempre libre)
  // ==========================================================
  let busy = false;
  const setBusy = (state) => {
    busy = !!state;
    for (const b of $$('[data-action]')) {
      const act = b.getAttribute('data-action');
      if (act === 'go-checkout') continue;
      b.classList.toggle('btn-disabled', !!state);
      if (state) b.setAttribute('aria-disabled','true');
      else b.removeAttribute('aria-disabled');
    }
  };

  // ==========================================================
  // Refresh (retry 1 vez con backoff)
  // ==========================================================
  let lastRefreshAt = 0;
  const refresh = async (retry = true) => {
    // evita spamear refresh si se llama muchas veces (por errores)
    const t = nowMs();
    if (t - lastRefreshAt < 180) return;
    lastRefreshAt = t;

    if (busy) return;
    setBusy(true);
    say("Actualizando carrito…");

    try {
      const d = await apiGet('/cart/json', 'refresh');
      const snap = pickCart(d);
      applySnap(snap);
      say("Carrito actualizado.");
    } catch (e) {
      if (retry) {
        setTimeout(() => refresh(false), 280);
      } else {
        toastSafe("Ups", e.message || "No se pudo actualizar");
        say("Error al actualizar.");
      }
    } finally {
      setBusy(false);
    }
  };

  // ==========================================================
  // Debounce map
  // ==========================================================
  const debounceMap = new Map();
  const debounce = (key, fn, ms = 320) => {
    if (debounceMap.has(key)) clearTimeout(debounceMap.get(key));
    debounceMap.set(key, setTimeout(fn, ms));
  };

  // ==========================================================
  // Commit qty helper (reutilizable)
  // ==========================================================
  const commitQty = async (id, qty) => {
    const pid = safeStr(id, "");
    if (!pid) return;

    const q = clamp(toInt(qty, 1), 1, 25);

    try {
      setBusy(true);
      say("Actualizando cantidad…");
      const d = await apiPost('/cart/update?json=1', { id: pid, qty: q }, 'qty');
      const snap = pickCart(d);
      applySnap(snap);
      say("Cantidad actualizada.");
    } catch (e) {
      toastSafe("Ups", e.message || "No se pudo actualizar");
      say("Error al actualizar.");
      refresh(); // rollback seguro
    } finally {
      setBusy(false);
    }
  };

  // ==========================================================
  // Click actions
  // ==========================================================
  root.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('[data-action]');
    if (!btn) return;

    const action = btn.getAttribute('data-action') || "";
    const id = btn.getAttribute('data-id') || "";

    // ✅ Checkout PRO (nunca bloqueado)
    if (action === 'go-checkout') {
      ev.preventDefault();
      if (btn.dataset.loading === '1') return;

      btn.dataset.loading = '1';
      const original = btn.textContent;
      btn.textContent = 'Redirigiendo...';
      btn.classList.add('btn-disabled');
      say("Redirigiendo al checkout…");

      window.location.href = btn.getAttribute('href') || '/cart/checkout';

      setTimeout(() => {
        btn.textContent = original;
        btn.dataset.loading = '0';
        btn.classList.remove('btn-disabled');
      }, 2500);
      return;
    }

    if (action === 'refresh') return refresh();
    if (busy) return;

    try {
      if (action === 'clear') {
        setBusy(true);
        say("Vaciando carrito…");
        const d = await apiPost('/cart/clear?json=1', {}, 'clear');
        const snap = pickCart(d);
        applySnap(snap);
        toastSafe("Listo", "Carrito vacío ✅");
        say("Carrito vacío.");
        return;
      }

      if (action === 'remove') {
        setBusy(true);

        // optimistic UI remove
        const row = root.querySelector(`[data-line][data-id="${CSS.escape(id)}"]`);
        if (row) { row.classList.add('fade-out'); setTimeout(() => row.remove(), 220); }

        say("Quitando producto…");
        const d = await apiPost('/cart/remove?json=1', { id }, 'remove');
        const snap = pickCart(d);
        applySnap(snap);
        toastSafe("Listo", "Producto quitado ✅");
        say("Producto quitado.");
        return;
      }

      if (action === 'inc' || action === 'dec') {
        const input = root.querySelector(`[data-qty-input][data-id="${CSS.escape(id)}"]`);
        const current = input ? toInt(input.value, 1) : 1;
        const next = action === 'inc' ? current + 1 : current - 1;
        const qty = clamp(next, 1, 25);
        if (input) input.value = String(qty);
        await commitQty(id, qty);
        return;
      }
    } catch (e) {
      toastSafe("Ups", e.message || "Error");
      say("Ocurrió un error.");
      refresh();
    }
  });

  // ==========================================================
  // Qty input manual (debounced + commit on blur)
  // ==========================================================
  root.addEventListener('input', (ev) => {
    const inp = ev.target.closest('[data-qty-input]');
    if (!inp) return;

    const id = inp.getAttribute('data-id') || "";
    debounce(`qty:${id}`, async () => {
      if (busy) return;

      let qty = clamp(toInt(inp.value, 1), 1, 25);
      inp.value = String(qty);
      await commitQty(id, qty);
    }, 380);
  });

  root.addEventListener('blur', (ev) => {
    const inp = ev.target.closest('[data-qty-input]');
    if (!inp) return;

    const id = inp.getAttribute('data-id') || "";
    let qty = clamp(toInt(inp.value, 1), 1, 25);
    inp.value = String(qty);

    // commit inmediato al salir del input (sin esperar debounce)
    debounce(`qtyblur:${id}`, () => commitQty(id, qty), 0);
  }, true);

  // Enter / Escape helpers
  root.addEventListener('keydown', (ev) => {
    const inp = ev.target.closest('[data-qty-input]');
    if (!inp) return;

    if (ev.key === 'Enter') {
      ev.preventDefault();
      inp.blur();
    }
    if (ev.key === 'Escape') {
      ev.preventDefault();
      refresh();
      inp.blur();
    }
  });

  // ✅ Primera sync
  refresh();
});
</script>
